#!/usr/bin/perl
#
# style-search
#
# This Gearman worker is responsible for taking a style search query and
# and performing the search
#
# Authors:
#      Momiji <momijizukamori@gmail.com>
#
# Copyright (c) 2009-2013 by Dreamwidth Studios, LLC.
#
# This program is free software; you may redistribute it and/or modify it under
# the same terms as Perl itself.  For a copy of the license, please reference
# 'perldoc perlartistic' or 'perldoc perlgpl'.
#


use strict;
use lib "$ENV{LJHOME}/extlib/lib/perl5";
use lib "$ENV{LJHOME}/cgi-bin";
BEGIN {
    require "ljlib.pl";
}

use Gearman::Worker;
use LJ::Worker::Gearman;
use Storable;

gearman_decl( 'style_search' => \&style_search );
gearman_work();



#Build tag hash structure that looks like this:
#%TAG_HASH = (
#    %tagid => [ style, style, style... ],
#    %tagid2 => [ style, style, style... ],
#)


sub _get_tag_hash {

    my %taglist;
    my $dbr = LJ::S2::get_s2_reader();

    my $sth = $dbr->prepare("SELECT s.s2lid, k.keyword ".
                            "FROM s2categories s, sitekeywords k ".
                            "WHERE s.kwid=k.kwid");
    $sth->execute();
    die $sth->errstr if $sth->err;
    while (my ($s2lid, $keyword) = $sth->fetchrow_array) {

            my @s2list = $taglist{$keyword} ? ( @{$taglist{$keyword}}, $s2lid ) : $s2lid;
            $taglist{$keyword} = \@s2list;
    }

    return %taglist;
}


sub _match_or {

    my $category = shift;
    my @opts_list = @{ shift() };
    my %taglist = %{ shift() };
    my @s2lid_list;

    while (@opts_list) {
        my $full_cat = $category . " " . shift(@opts_list);

        push (@s2lid_list, @{$taglist{$full_cat}});
#        warn "this is our current list:";
#        warn LJ::D(\@s2lid_list);
    }


    #FIXME: We need to remove duplicates!
    return @s2lid_list;
}

sub _match_and {

    my $category = shift;
    my @opts_list = @{ shift() };
    my %taglist = %{ shift() };
    my @s2lid_list;
    my @updated_s2lid_list;
    my %updated_s2lid_hash;

    while (@opts_list) {
        my $full_cat = $category . " " . shift(@opts_list);
        my @cat_list = @{$taglist{$full_cat}};

#        warn $full_cat;
#        warn LJ::D(\@cat_list);
#        warn "this is our current list";
#            warn LJ::D(\@updated_s2lid_list);

        if (@updated_s2lid_list) {
#            warn "our list before running the match:";
#            warn LJ::D(\@updated_s2lid_list);
#            warn "our currrent category list:";
#            warn LJ::D(\@cat_list);

            my %updated_s2lid_hash = map {$_ => 1} @updated_s2lid_list;
#            warn "our hash map:";
#            warn LJ::D(\%updated_s2lid_hash);
            @updated_s2lid_list = grep $updated_s2lid_hash{$_}, @cat_list;

#            warn "our list after running the match:";
#            warn LJ::D(\@updated_s2lid_list);

        } else {
            @updated_s2lid_list = @cat_list;
        }

    }

    return @updated_s2lid_list;
}

sub style_search {
    my %taglist;
    my $job = shift;
    my $queryref = Storable::thaw( $job->arg );
    my %query = %$queryref;
    my @layoutslist;
    my %layoutshash;

    print STDERR "This is our query:";
    print STDERR LJ::D(%query);

    if (0) { #fix this about
 #       %taglist = %{cachedtaglistref}
    } else {
        %taglist = _get_tag_hash();
        #CACHE THIS????
    }

#    print STDERR "This is our taglist:";
#    print STDERR LJ::D(\%taglist);

    #Query form:
    #%query = (
    #    %category = ( $match => and, @opts => ( opt1 opt2 opt3)),
    #    %category2 = ($match => or, @opts => (opt2 opt3)),
    #)

    for my $query_item (keys %query) {
        if ($query{$query_item} -> {match_type} eq "and") {
#            warn "Running an and!\n";
            @layoutslist =  _match_and($query_item, \@{$query{$query_item}->{opts}}, \%taglist);
#           warn "this is our current layout list after 'and' match:";
#            warn LJ::D(\@layoutslist);

            #dump empty (no-result) lists
            if(@layoutslist) { $layoutshash{$query_item} = [@layoutslist]; }
#            warn "this is our current layout hash after 'and' match:";
#            warn LJ::D(\%layoutshash);
        } elsif ($query{$query_item} -> {match_type} eq "or") {
#            warn "Running an or!\n";
            @layoutslist =  _match_or($query_item, \@{$query{$query_item}->{opts}}, \%taglist);
#            warn "this is our current layout list after 'or' match:";
#            warn LJ::D(\@layoutslist);

            #dump empty (no-result) lists
            if(@layoutslist) { $layoutshash{ $query_item } = [@layoutslist]; };
#            warn "this is our current layout hash after 'or' match:";
#            warn LJ::D(\%layoutshash);
        } else {
        warn "No match running!";
        };

    }

            warn "this is our current layout hash after all matches:";
            warn LJ::D(\%layoutshash);

    my @queried_layouts;

    #now we take all our seperate category lists and run 'and' matches between them
    for my $category (keys %layoutshash) {

#        warn "this is our current last list";
#        warn LJ::D(\@queried_layouts);
        if (@queried_layouts) {
            my %queriedhash = map{$_ =>1} @queried_layouts;

#        warn "this is our current hash map";
#        warn LJ::D(\%queriedhash);

#        warn "this is what we're matching against";
#        warn LJ::D(\$layoutshash{$category});
            @queried_layouts = grep $queriedhash{$_}, @{$layoutshash{$category}};

#        warn "this is our current last list after match";
#        warn LJ::D(\@queried_layouts);
        } else {
            @queried_layouts = @{$layoutshash{$category}};
        }

    }

    warn "This is what we're returning:";
    warn LJ::D(\@queried_layouts);
    my $results = Storable::nfreeze( \@queried_layouts );
    return \$results;
}
